using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.X509;

namespace U2F.Core.Crypto
{
    public interface ICrytoService
    {
        /// <summary>
        /// Generated a securely generated byte array //TODO what algorithm
        /// </summary>
        /// <returns>Securely generated random bytes</returns>
        byte[] GenerateChallenge();

        /// <summary>
        /// Checks the signature.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="src">The source.</param>
        /// <param name="signature">The signature.</param>
        /// <returns></returns>
         bool CheckSignature(ICipherParameters key, byte[] src, byte[] signature);

        /// <summary>
        /// Checks the signature.
        /// </summary>
        /// <param name="attestationCertificate">The attestation certificate.</param>
        /// <param name="signedBytes">The signed bytes.</param>
        /// <param name="signature">The signature.</param>
        /// <returns></returns>
        bool CheckSignature(X509Certificate attestationCertificate, byte[] signedBytes, byte[] signature);

        /// <summary>
        /// Decodes the public key.
        /// </summary>
        /// <param name="encodedPublicKey">The encoded public key.</param>
        /// <returns></returns>
        ICipherParameters DecodePublicKey(byte[] encodedPublicKey);

        /// <summary>
        /// Hashes the specified bytes.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <returns>byte array of hashed byte array</returns>
        byte[] Hash(byte[] bytes);

        /// <summary>
        /// Hashes the specified string with sha256.
        /// </summary>
        /// <param name="stringToHash">The string to be hased.</param>
        /// <returns>byte array of hashed string</returns>
        byte[] Hash(string stringToHash);
    }
}